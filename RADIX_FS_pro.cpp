#include<iostream>
#include<fstream>
#include<stdlib.h>
#include<string>
#include<sstream>
#pragma warning (disable:4996)
using namespace std;
//total size refer total number of records
int Totalsize = 20;
string keyId;


class Student
{
	public:
		string Student_usn, Student_name, Student_sem;
		void insert_data();
		void pack();
		void unpack(int);
		void display_data();
}Student;

fstream fp;
//int Hashfunction(string);
void search();
int first_bit(int);
void error(int);
int newHashFunction(string);
int stringToNumber(char);

int main()
{
	int choice;
	system("clear");
	fp.open("student.txt", ios::out);
	fp.close();
	
	while(1)
	{
		cout << "\n--------------------------------------------------------" << endl;
		cout << "1.Insert element into record" << endl;
		cout << "2.Search" << endl;
		cout << "3.Exit" << endl;
		cout << "Enter your choice: ";
		cin >> choice;
		switch (choice)
		{
			case 1: Student.insert_data();
					Student.pack();
					break;
					
			case 2: search();
					break;
					
			case 3: exit(0);
			
			default : cout << "Wrong choice \n";
		}
	}
}

//Hashfunction
/*
int Hashfunction(string Student_usn)
{
	int sum = 0;
	string s1 = Student_usn;
	int len = s1.length();
	if (len%2 == 1) len++;
	string ss = s1.substr(len-3,3);
	stringstream str(ss);
	int x = 0;
	ss >> x;
	stringstream temp();
	temp << hex << x;
	string res = temp.str();
		for (int j = 0; j < len; j+=2)
		sum = (res + 100 * Student_usn[j] + Student_usn[j+1] )%19937;
	cout << "Address Generated by Hash : " << (sum%Totalsize)*54<<endl;
	return (sum % Totalsize) * 54;
	
}
*/
int newHashFunction(string Student_usn)
{
	int sum = 0;
	string backupStr = Student_usn;
	int len = backupStr.length();
	if (len%2 == 1) len++;
	string newStr = backupStr.substr(len-3,3);
	cout << newStr;
	stringstream str(newStr);
	int x;
	std::stringstream (newStr) >> x;

	std::stringstream stream;
	stream << std::hex << x;
	std::string res = stream.str();
	int number = stringToNumber(res[0]);
		for (int j = 0; j < len; j+=2)
		sum = (number + 100 * Student_usn[j] + Student_usn[j+1] )%19937;
		
	cout << "Sum : " << sum << endl;	
	cout << "Address Generated by Hash : " << (sum%Totalsize)*54<<endl;
	return (sum % Totalsize) * 54;
	
}
int stringToNumber(char input){
	//int len = length(input);
	//return stringToNumber(input,len-1);
	int atoi (const char * input); 
}

//input student details
void Student::insert_data()
{
	cout << "Enter Student_usn: " << endl;
	cin >> Student_usn;
	cout << "Enter Student name: " << endl;
	cin >> Student_name;
	cout << "Enter Student sem: " << endl;
	cin >> Student_sem;
}

//pack function to insert data
void Student::pack()
{
	int flag = 0;
	int First_Bit, position;
	char temp[100];
	string buffer = Student_usn + "|" + Student_name + "|" + Student_sem + "|";
	
	//details should not exceed size 50
	if (buffer.length() > 50)
	{
		error(2);
		return;
	}
	//append remaining space with *
	while (buffer.length() < 50)
			buffer += '*';
			
	//call hashfunction to generate location
	
	position = newHashFunction(Student_usn);
	fp.open("student.txt", ios::in);
	
	fp.seekg(position, ios::beg);
	fp.getline(temp, 100);
	fp.close();
	
	First_Bit = temp[0] - 48;
	
	//cout << First_Bit << endl;
	
	fp.open("student.txt", ios::out  | ios::in);
	if (!fp)
			error(1);
	if (First_Bit < 0)
	{
		position = first_bit(position);
		flag = 1;
	}
	
	else if (First_Bit == 1)
	{
		cout << "collision is occoured\n";
		
		int tempPos = position;
		//search for next succesive location
		for (position = position + 54; position <= ((Totalsize - 1) * 54); position = position + 54)
		{
			fp.seekg(position, ios::beg);
			fp.getline(temp, 100);
			fp.close();
			
			First_Bit = temp[0] - 48;
			
			fp.open("student.txt", ios::out | ios::in);
			if (!fp)
					error(1);
			if (First_Bit < 0)
			{
				position = first_bit(position);
				flag = 1;
				break;
			}
		}
		//search from beginning
		if (position == Totalsize * 54)
		{
			for (position = 0; position< tempPos; position = position + 54)
			{
				fp.seekg(position, ios::beg);
				fp.getline(temp, 100);
				fp.close();
				
				First_Bit = temp[0] - 48;
				
				fp.open("student.txt", ios::out | ios::in);
				
				if (!fp)
						error(1);
				if (First_Bit < 0)
				{
					position = first_bit(position);
					flag = 1;
					break;
				}
			}
		}
	}
	if (flag == 1) {
		int address = position - 2;
		cout << "Record is generated at the address : "<< address << endl;
		fp.seekp(position, ios::beg);
		fp << buffer << endl;
		fp.close();
	}
	//connot insert anymore record
	else {
		cout << "connot insert record anymore, No space " << endl;
	}
	fp.close();
}

int first_bit(int position)
{
	fp.seekp(position, ios::beg);
	fp.put('1');
	position = position + 1;
	fp.seekp(position, ios::beg);
	fp.put('|');
	position = position + 1;
	return position;
}


void search() {
	
	char temp[100];
	int tempPos, position , i , flag = 0, First_Bit;
	
	cout << "\n Enter the Student_usn to search : ";
	cin >> keyId;
	position = newHashFunction(keyId);
	tempPos = position;
	
	for (position = position; position <= ((Totalsize - 1) * 54); position = position + 54)
	{
		Student.unpack(position);
		if (keyId == Student.Student_usn)
		{
			flag = 1;
			break;
		}
	}
	if (position == Totalsize * 54)
	{
		for (position = 0; position < tempPos; position = position + 54)
		{
			Student.unpack(position);
			if (keyId == Student.Student_usn)
			{
				flag = 1;
				break;
			}
		}
	}
	fp.close();
	if (!flag)
	{
		cout << "Record not found \n";
		return;
	}
	else
	{
		cout << "Record found \n";
		Student.display_data();
	}
}

void Student::unpack(int position)
{
	char tempbuffer[100];
	string seg;
	fp.open("Student.txt", ios::in);
	fp.seekg(position, ios::beg);
	fp.getline(tempbuffer, 100);
	fp.seekg((position + 2), ios::beg);
	//fp.getline(tempbuffer, 100);
	
	
	getline(fp, Student_usn, '|');
	getline(fp, Student_name, '|');
	getline(fp, Student_sem, '|');
	fp.close();
}

void Student::display_data()
{
	cout << "\nStudent_usn: " << Student_usn << "\nStudent_name: " << Student_name << "\nStudent_sem: " << Student_sem << endl;
}

void error(int error_type)
{
	switch (error_type)
	{
		case 1: cout << "\nFATAL ERROR!! : unable to open file \n";
				exit(0);
				
		case 2: cout << "\n ERROR!! : Data exceeds record length\n";
				return;
	}
}
